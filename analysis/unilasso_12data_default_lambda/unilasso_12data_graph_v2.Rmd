# Final version Part 1 for MSE: combine stability with mse, support, sign_diff 9/15 Monday updates 
```{r combine stability with mse, support, sign_diff}
### setup####

if (R.home() != "/scratch/users/aqwang/conda/envs/r_package/lib/R") {
  system("/scratch/users/aqwang/conda/envs/r_package/bin/Rscript -e 'rmarkdown::render(\"unilasso_12data_graph_final.Rmd\")'")
  quit("no")
}

# check the R environment is r_package
R.home()

# set working directory
setwd("/accounts/grad/aqwang/unilasso/analysis/unilasso_12data_default_lambda")

# load packages 
library(uniLasso) # for unilasso 
library(glmnet) # for cv lasso 
library(tidyr)

# Define all dataset names (remove "data_" prefix)
dataset_names <- c(
  "ca_housing", "computer",
  "debutanizer", "diamond", "elevator", "energy_efficiency",
  "insurance", "kin8nm", "miami_housing", "naval_propulsion",
 "protein_structure", "qsar")

 
 library(ggh4x)
library(tidyverse)
library(ggplot2)
library(dplyr)
library(grid)       # for viewport functions
library(ggtext)  # Add this library for geom_richtext
library(scales)


####################################################



###################(1)load results for mse, support, sign_diff#################
# read csv file
results_all_splits <- read.csv("/accounts/grad/aqwang/unilasso/analysis/unilasso_12data_default_lambda/unilasso_12data_100splits_train50percentresults.csv")


# using results_all_splits data frame to graph boxplot of MSE on the left and boxplot of support on the right for each dataset 


# Reshape data for plotting
plot_long <- results_all_splits %>%
  select(dataset, split_id, unilasso_loo_true_mse, polish_unilasso_mse, lasso_cv_mse, unireg_mse, least_squares_mse,
         unilasso_loo_true_support, polish_unilasso_support, lasso_cv_support,unireg_support, least_squares_support,
         unilasso_loo_true_sign_diff, polish_unilasso_sign_diff,lasso_cv_sign_diff,unireg_sign_diff, least_squares_sign_diff) %>%
  pivot_longer(
    cols = c(unilasso_loo_true_mse, polish_unilasso_mse, lasso_cv_mse, unireg_mse, least_squares_mse,
             unilasso_loo_true_support, polish_unilasso_support, lasso_cv_support, unireg_support, least_squares_support,
             unilasso_loo_true_sign_diff, polish_unilasso_sign_diff, lasso_cv_sign_diff, unireg_sign_diff, least_squares_sign_diff),
    names_to = c("method", ".value"),
    names_pattern = "(unilasso_loo_true|polish_unilasso|lasso_cv|unireg|least_squares)_(mse|support|sign_diff)"
  )

# Order datasets for consistent facetting
desired_order <- c(
  "ca_housing", "debutanizer", "insurance", "kin8nm", 
  "computer", "elevator", "energy_efficiency", "miami_housing", "naval_propulsion",
  "diamond", "protein_structure", "qsar"
)


plot_long$dataset <- factor(plot_long$dataset, levels = desired_order)

# rename unilasso_loo_true to unilasso
plot_long$method <- recode(plot_long$method, unilasso_loo_true = "uniLasso", polish_unilasso = "Polish", lasso_cv = "Lasso", unireg = "uniReg", least_squares = "LS")

# After creating plot_long and recoding the method names, add this line:
plot_long$method <- factor(plot_long$method, levels = c("LS", "Lasso", "uniReg", "uniLasso", "Polish"))

#rename all datasets to have first letter capitalized and underscores replaced with spaces
plot_long$dataset <- recode(plot_long$dataset,
                            "ca_housing" = "CA housing",
                            "debutanizer" = "Debutanizer",
                            "insurance" = "Insurance",
                            "kin8nm" = "Kin8nm",
                            "computer" = "Computer",
                            "elevator" = "Elevator",
                            "energy_efficiency" = "Energy efficiency",
                            "miami_housing" = "Miami housing",
                            "naval_propulsion" = "Naval propulsion",
                            "diamond" = "Diamond",
                            "protein_structure" = "Protein structure",
                            "qsar" = "QSAR"
)

# Create combined long data with metric type including sign_diff
plot_combined_long <- plot_long %>%
  pivot_longer(
    cols = c(mse, support, sign_diff),
    names_to = "metric",
    values_to = "value"
  ) %>%
  mutate(
    metric = recode(metric, 
                   "mse" = "MSE", 
                   "support" = "Support",
                   "sign_diff" = "Number of violations"),
    metric = factor(metric, levels = c("MSE", "Support", "Number of violations"))
  )


#########################################################


###################(2)calculate stability for all our 12 datasets. 9/19 Friday updates#################
library(dplyr)
library(utils)  # for combn function

# Function to calculate stability for a given method - returns all pairwise values
calculate_stability_full <- function(data, method_name) {
  # Filter data for the specific method
  method_data <- data %>% filter(method == method_name)
  
  # Extract coefficient columns (starting from column 4)
  coef_matrix <- as.matrix(method_data[, 4:ncol(method_data)])
  
  # Number of models for this method
  n_models <- nrow(coef_matrix)
  
  if (n_models < 2) {
    return(c())  # Return empty vector if not enough models
  }
  
  # Generate all pairs of models (100 choose 2)
  model_pairs <- combn(1:n_models, 2, simplify = FALSE)
  
  # Calculate stability for each pair
  stability_values <- sapply(model_pairs, function(pair) {
    model_i <- pair[1]
    model_j <- pair[2]
    
    # Find selected features (non-zero coefficients) for each model. returns the indices (column numbers) where the coefficients are nonzero.
    features_i <- which(coef_matrix[model_i, ] != 0)
    features_j <- which(coef_matrix[model_j, ] != 0)
    
    # Calculate Jaccard similarity: |intersection| / |union|
    common_features <- length(intersect(features_i, features_j))
    total_unique_features <- length(union(features_i, features_j))
    
    # Handle case where both models select no features
    if (total_unique_features == 0) {
      return(1)  # Perfect stability if both select nothing
    } else {
      return(common_features / total_unique_features)
    }
  })
  
  # Return the entire vector of stability values
  return(stability_values)
}

# Get all CSV files in the coef_csv directory
coef_csv_dir <- "/accounts/grad/aqwang/unilasso/analysis/unilasso_12data_default_lambda/coef_csv_12datasets_default_lambda"
csv_files <- list.files(coef_csv_dir, pattern = "coefficients_.*\\.csv$", full.names = TRUE)

# check dataset names from file names
dataset_names <- gsub("coefficients_(.+)\\.csv", "\\1", basename(csv_files))
print(dataset_names)  # Verify dataset names

# Initialize storage for all results
all_stability_results <- data.frame(
  dataset = character(),
  method = character(),
  mean_stability = numeric(),
  sd_stability = numeric(),
  min_stability = numeric(),
  max_stability = numeric(),
  n_pairs = integer(),
  stringsAsFactors = FALSE
)

# Initialize storage for detailed results (optional - if you want all pairwise values)
all_stability_detailed <- list()

# Loop through all datasets
for (i in seq_along(csv_files)) {
  dataset_name <- dataset_names[i]
  csv_file <- csv_files[i]
  
  cat("\n", strrep("=", 60), "\n")
  cat("Processing dataset:", dataset_name, "(", i, "/", length(csv_files), ")\n")
  cat(strrep("=", 60), "\n")
  
  # Read coefficient data
  tryCatch({
    coefficients_data <- read.csv(csv_file)
    # Remove rows with method=unilasso_loo_false
    coefficients_data <- coefficients_data[coefficients_data$method != "unilasso_loo_false", ]
    coefficients_data <- coefficients_data[coefficients_data$method != "uni_loo", ]
    
    # Get unique methods in this dataset
    unique_methods <- unique(coefficients_data$method)
    cat("Found methods:", paste(unique_methods, collapse = ", "), "\n")
    
    # Calculate stability for each method in this dataset
    dataset_stability_detailed <- list()
    
    for (method in unique_methods) {
      cat("  Processing method:", method, "...")
      
      # Calculate full stability vector for this method
      stability_vector <- calculate_stability_full(coefficients_data, method)
      
      if (length(stability_vector) > 0) {
        # Clean method name
        clean_method <- recode(method,
          "unilasso_loo_true" = "uniLasso",
          "polish_unilasso" = "Polish",
          "lasso_cv" = "Lasso",
          "unireg" = "uniReg", 
          "least_squares" = "LS"
        )
        
        # Calculate summary statistics
        summary_stats <- data.frame(
          dataset = dataset_name,
          method = clean_method,
          mean_stability = mean(stability_vector, na.rm = TRUE),
          sd_stability = sd(stability_vector, na.rm = TRUE),
          min_stability = min(stability_vector, na.rm = TRUE),
          max_stability = max(stability_vector, na.rm = TRUE),
          n_pairs = length(stability_vector),
          stringsAsFactors = FALSE
        )
        
        # Add to main results dataframe
        all_stability_results <- rbind(all_stability_results, summary_stats)
        
        # Store detailed results (optional)
        dataset_stability_detailed[[clean_method]] <- stability_vector
        
        cat(" Done (", length(stability_vector), " pairs)\n")
        
      } else {
        cat(" Skipped (insufficient data)\n")
      }
    }
    
    # Store detailed results for this dataset
    all_stability_detailed[[dataset_name]] <- dataset_stability_detailed
    
    # Print summary for this dataset
    dataset_results <- all_stability_results[all_stability_results$dataset == dataset_name, ]
    if (nrow(dataset_results) > 0) {
      cat("\nSummary for", dataset_name, ":\n")
      for (j in 1:nrow(dataset_results)) {
        row <- dataset_results[j, ]
        cat(sprintf("  %-10s: Mean = %.3f (SD = %.3f) Range = [%.3f, %.3f] [%d pairs]\n",
                    row$method, row$mean_stability, row$sd_stability,
                    row$min_stability, row$max_stability, row$n_pairs))
      }
    }
    
  }, error = function(e) {
    cat("ERROR processing", dataset_name, ":", e$message, "\n")
  })
}

# Final summary
cat("\n", strrep("=", 80), "\n")
cat("STABILITY ANALYSIS COMPLETE!\n")
cat("Total datasets processed:", length(unique(all_stability_results$dataset)), "\n")
cat("Total method-dataset combinations:", nrow(all_stability_results), "\n")
cat(strrep("=", 80), "\n")

# Display overall results
print(all_stability_results)

# Save results
write.csv(all_stability_results, "stability_across100ransplits_12_data_summary.csv", row.names = FALSE)
save(all_stability_results, all_stability_detailed, file = "stability_across100ransplits_12_data.RData")


################# prepare stability data #################
library(ggplot2)

# Build one long data.frame: dataset, method, stability
make_long <- function(all_stability_detailed) {
  do.call(rbind, lapply(names(all_stability_detailed), function(ds) {
    methods <- all_stability_detailed[[ds]]
    if (length(methods) == 0) return(NULL)
    do.call(rbind, lapply(names(methods), function(m) {
      v <- methods[[m]]
      v <- v[is.finite(v)]                 # drop NA/Inf if present
      if (length(v) == 0) return(NULL)
      data.frame(dataset = ds, method = m, stability = v, 
                 stringsAsFactors = FALSE)
    }))
  }))
}

plot_data <- make_long(all_stability_detailed)


# Order datasets for consistent facetting
desired_order <- c(
  "ca_housing", "debutanizer", "insurance", "kin8nm", 
  "computer", "elevator", "energy_efficiency", "miami_housing", "naval_propulsion",
  "diamond", "protein_structure", "qsar"
)


plot_data$dataset <- factor(plot_data$dataset, levels = desired_order)

#rename all datasets to have first letter capitalized and underscores replaced with spaces
plot_data$dataset <- recode(plot_data$dataset,
                            "ca_housing" = "CA housing",
                            "debutanizer" = "Debutanizer",
                            "insurance" = "Insurance",
                            "kin8nm" = "Kin8nm",
                            "computer" = "Computer",
                            "elevator" = "Elevator",
                            "energy_efficiency" = "Energy efficiency",
                            "miami_housing" = "Miami housing",
                            "naval_propulsion" = "Naval propulsion",
                            "diamond" = "Diamond",
                            "protein_structure" = "Protein structure",
                            "qsar" = "QSAR"
)

# Use similar colors for Polish, uniLasso, and uniReg
method_colors <- c(
  "uniLasso" = "#e41a1c",  # bright red
  "Polish"   = "#e75480",  # medium pink
  "uniReg"   = "#b03060",  # deep rose/magenta
  "Lasso"    = "#2a6eb1",  # balanced medium blue
  "LS"       = "#505050"   # darker gray
)



########################(3) combine stability with mse, support, sign_diff########################
library(ggh4x)
library(tidyverse)
library(ggplot2)
library(dplyr)
library(grid)       # for viewport functions
library(ggtext)  # Add this library for geom_richtext
library(scales)


stability_data_formatted <- plot_data %>%
  rename(value = stability) %>%
  mutate(metric = "Stability") %>%
  mutate(split_id = NA) %>%  # Add split_id column with NA values to match other data %>%
  select(dataset, split_id, method, metric, value) # Reorder columns to match other data


# Combine all four metrics into one dataset
plot_combined_long_with_stability <- bind_rows(
  plot_combined_long,  # This has MSE, Support, and Number of violations
  stability_data_formatted  # This adds Stability
) %>%
  mutate(
    metric = factor(metric, levels = c("MSE", "Support", "Number of violations", "Stability"))
  ) %>%
  mutate(
    method = factor(method, levels = c("LS", "Lasso", "uniReg", "uniLasso", "Polish"))
  )


```

# Graph for the first 9 datasets 
```{R}
# Choose first 9 datasets (now with stability included)
plot_combined_long1_with_stability <- plot_combined_long_with_stability %>%
  filter(dataset %in% c("CA housing", "Debutanizer", "Insurance", "Kin8nm", "Computer", "Energy efficiency", "Miami housing", "Protein structure", "QSAR"))

# save plot_combined_long_with_stability to a csv file
#write.csv(plot_combined_long1_with_stability, "/accounts/grad/aqwang/unilasso/analysis/unilasso_12data_default_lambda/plot_combined_long_with_stability_12data.csv", row.names = FALSE)

# order datasets
plot_combined_long1_with_stability$dataset <- factor(plot_combined_long1_with_stability$dataset, levels = c("CA housing", "Debutanizer", "Insurance", "Kin8nm", "Computer", "Energy efficiency",  "Miami housing", "Protein structure", "QSAR"))   


# select only the MSE for the first 9 datasets
plot_combined_long1_mse <- plot_combined_long1_with_stability %>% filter(metric == "MSE")

# drop all splid_id if one of them has value NA
plot_combined_long1_mse <- plot_combined_long1_mse %>% group_by(dataset, split_id) %>% filter(!any(is.na(value))) %>% ungroup()

plot_combined_long1_mse <- plot_combined_long1_mse %>% group_by(dataset, split_id) %>% mutate(avg_mse_per_split = mean(value, na.rm = TRUE)) %>% ungroup() %>% group_by(dataset) %>% mutate(id_ordered = dense_rank(avg_mse_per_split)) %>% ungroup() %>% arrange(dataset, id_ordered)
View(plot_combined_long1_mse)


#colored version for the first 9 datasets 
mse_summary_table_simple <- plot_combined_long1_mse %>%
  group_by(dataset, method) %>%
  summarise(mean_mse = mean(value, na.rm = TRUE), .groups = "drop") %>%
  # Format the mean_mse but keep it as a separate column for HTML formatting
  mutate(
    formatted_mse = ifelse(mean_mse > 10000 | mean_mse < 0.1, 
                          formatC(mean_mse, format = "e", digits = 3), 
                          sprintf("%.3f", mean_mse)),
    method_chr = as.character(method),
    hex = unname(method_colors[method_chr])
  ) %>%
  group_by(dataset) %>%
  summarise(
    table_text_colored = paste(
      "<b>Mean MSE:</b>",
      paste0("<span style='color:", hex, "'>",
             method_chr, ": ", formatted_mse, "</span>",  # Use formatted_mse instead
             collapse = "<br>"),
      sep = "<br>"
    ),
    .groups = "drop"
  )


# Custom labeling function that uses scientific notation for very large/small numbers
scientific_if_needed <- function(x) {
  ifelse(abs(x) >= 10000 | (abs(x) < 0.09 & abs(x) > 0),
         formatC(x, format = "e", digits = 2),
         formatC(x, format = "f", digits = 3))
}

p_mse_ordered_with_avgMSE <- ggplot(plot_combined_long1_mse, aes(x = id_ordered, y = value, color = method)) +
  geom_point(alpha = 0.7) +
  geom_line(alpha = 0.7) +
  # Add table as single text block with colored text
  geom_richtext(data = mse_summary_table_simple,
                aes(x = -Inf, y = Inf, label = table_text_colored),
                hjust = -0.05, vjust = 1.05,
                size = 6, family = "Times New Roman", fontface = "bold",
                fill = NA,        
                label.color = "gray30",   # Dark gray border
                label.padding = unit(0.35, "lines"),
                label.r = unit(0.2, "lines"),  # Rounded corners
                inherit.aes = FALSE) +
  facet_wrap(~ dataset, scales = "free_y") +
  # Force max value to appear on y-axis
  scale_y_continuous(
    breaks = function(x) {
      # Get pretty breaks
      pretty_breaks <- pretty(x, n = 5)
      # Always include the maximum value
      unique(c(pretty_breaks, max(x)))
    },
    labels = scientific_if_needed  # Custom conditional formatting
    )+
  labs(x = "Split index sorted by mean MSE across methods", y = "MSE", color = "Method") +
  scale_color_manual(values = method_colors) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 1, size = 23, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 23, family = "Times New Roman", face = "bold"),  
    axis.title = element_text(size = 23, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.text = element_text(size = 25, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 25, family = "Times New Roman", face = "bold"),
    legend.key.size = unit(6, "lines"),   # << increase dot/line box size
    legend.key.width = unit(8, "lines"),  # << make lines wider
    strip.text = element_text(size = 25, family = "Times New Roman", face = "bold"),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
ggsave("/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/p_mse_line_12data9.png", 
       plot =p_mse_ordered_with_avgMSE,  width = 18, height = 26, dpi = 300)
print(p_mse_ordered_with_avgMSE)



# Support for the first 9 datasets
# select only the support for the first 9 datasets
plot_combined_long1_supp <- plot_combined_long1_with_stability %>%
  filter(metric == "Support", !is.na(value))

# Separate data for QSAR and non-QSAR datasets
plot_combined_long1_supp_qsar <- plot_combined_long1_supp %>%
  filter(dataset == "QSAR")

plot_combined_long1_supp_other <- plot_combined_long1_supp %>%
  filter(dataset != "QSAR")

# Create bar plot with different expansions
p_support_bar9 <- ggplot() +
  # Plot for non-QSAR datasets with normal expansion
  geom_bar(
    data = plot_combined_long1_supp_other,
    aes(y = as.factor(value), fill = method),
    orientation = "y",
    alpha = 0.7
  ) +
  # Plot for QSAR dataset (will be handled by separate scale)
  geom_bar(
    data = plot_combined_long1_supp_qsar,
    aes(y = as.factor(value), fill = method),
    orientation = "y",
    alpha = 0.7
  ) +
  facet_grid2(dataset ~ method,
              scales = "free",
              independent = "x") +
  # Use ggh4x::facetted_pos_scales to apply different scales per facet
  ggh4x::facetted_pos_scales(
    y = list(
      # For QSAR dataset
      dataset == "QSAR" ~ scale_y_discrete(
        labels = function(x) sprintf("%.0f", as.numeric(as.character(x))),
        breaks = function(x) {
          n_ticks <- min(8, length(x))
          x[seq(1, length(x), length.out = n_ticks)]
        },
        expand = expansion(add = 30)  # Special expansion for QSAR
      ),
      # For all other datasets
      dataset != "QSAR" ~ scale_y_discrete(
        labels = function(x) sprintf("%.0f", as.numeric(as.character(x))),
        breaks = function(x) {
          n_ticks <- min(8, length(x))
          x[seq(1, length(x), length.out = n_ticks)]
        },
        expand = expansion(add = 2)  # Normal expansion
      )
    )
  ) +
  coord_cartesian(expand = TRUE, clip = "off") +
  labs(x = "Count", y = "Support", fill = "Method") +
  scale_fill_manual(values = method_colors) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 10, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 10, family = "Times New Roman", face = "bold"),
    axis.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.text = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    strip.text = element_text(size = 12, family = "Times New Roman", face = "bold"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

# Display plot
print(p_support_bar9)

ggsave("/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/p_support_bar_12data9.png", 
      plot = p_support_bar9,  width = 9, height = 15, dpi = 300)


# number of violations bar plot for the first 9 datasets
# select only the number of violations for the first 9 datasets
plot_combined_long1_sign <- plot_combined_long1_with_stability %>%
  filter(metric == "Number of violations", !is.na(value))

# Create bar plot
p_sign_bar9 <- ggplot(plot_combined_long1_sign, aes(y = as.factor(value), fill = method)) +
  geom_bar(
    orientation = "y",
    #color = "gray",       # Border around bars
    #linewidth = 0.3,
    alpha = 0.7
  ) +
  facet_grid2(dataset ~ method,
              scales = "free",
              independent = "x") +
  scale_y_discrete(
    labels = function(x) sprintf("%.0f", as.numeric(as.character(x))),  # Format support as integers
    breaks = function(x) {
      # Limit to at most 8 evenly spaced ticks
      n_ticks <- min(8, length(x))
      x[seq(1, length(x), length.out = n_ticks)]
    },
    expand = expansion(add = 2)  # Add slight space above and below
  ) +
  labs(x = "Count", y = "Number of violations", fill = "Method") +
  scale_fill_manual(values = method_colors) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 10, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 10, family = "Times New Roman", face = "bold"),
    axis.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.text = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    strip.text = element_text(size = 12, family = "Times New Roman", face = "bold"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
# Display plot
print(p_sign_bar9)
ggsave("/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/p_sign_bar_12data9.png", 
       plot = p_sign_bar9,  width = 9, height = 15, dpi = 300)



# Stability bar plot for the first 9 datasets
# select only the stability for the first 9 datasets
plot_combined_long1_stab <- plot_combined_long1_with_stability %>%
  filter(metric == "Stability", !is.na(value))

# Separate data for QSAR and non-QSAR datasets
plot_combined_long1_stab_qsar <- plot_combined_long1_stab %>%
  filter(dataset == "QSAR")

plot_combined_long1_stab_other <- plot_combined_long1_stab %>%
  filter(dataset != "QSAR")

# Create bar plot with different expansions
p_stab_bar9 <- ggplot() +
  # Plot for non-QSAR datasets with normal expansion
  geom_bar(
    data = plot_combined_long1_stab_other,
    aes(y = as.factor(value), fill = method),
    orientation = "y",
    alpha = 0.7
  ) +
  # Plot for QSAR dataset (will be handled by separate scale)
  geom_bar(
    data = plot_combined_long1_stab_qsar,
    aes(y = as.factor(value), fill = method),
    orientation = "y",
    alpha = 0.7
  ) +
  facet_grid2(dataset ~ method,
              scales = "free",
              independent = "x") +
  # Use ggh4x::facetted_pos_scales to apply different scales per facet
  ggh4x::facetted_pos_scales(
    y = list(
      # For QSAR dataset
      dataset == "QSAR" ~ scale_y_discrete(
        labels = function(x) sprintf("%.2f", as.numeric(as.character(x))),
        breaks = function(x) {
          n_ticks <- min(8, length(x))
          x[seq(1, length(x), length.out = n_ticks)]
        },
        expand = expansion(add = 1000)  # Special expansion for QSAR
      ),
      # For all other datasets
      dataset != "QSAR" ~ scale_y_discrete(
        labels = function(x) sprintf("%.2f", as.numeric(as.character(x))),
        breaks = function(x) {
          n_ticks <- min(8, length(x))
          x[seq(1, length(x), length.out = n_ticks)]
        },
        expand = expansion(add = 2)  # Normal expansion
      )
    )
  ) +
  coord_cartesian(expand = TRUE, clip = "off") +
  labs(x = "Count", y = "Random-split stability", fill = "Method") +
  scale_fill_manual(values = method_colors) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust=1, size = 10, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 10, family = "Times New Roman", face = "bold"),
    axis.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.text = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    strip.text = element_text(size = 12, family = "Times New Roman", face = "bold"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

# Display plot
print(p_stab_bar9)
ggsave("/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/p_stab_bar_12data9.png", 
       plot = p_stab_bar9,  width =9, height = 17, dpi = 300)
```


# Graph for last 3 datasets
```{R}
# Choose last 3 datasets (now with stability included)
plot_combined_long2_with_stability <- plot_combined_long_with_stability %>%
  filter(dataset %in% c("Elevator", "Diamond", "Naval propulsion"))

# order datasets
plot_combined_long2_with_stability$dataset <- factor(plot_combined_long2_with_stability$dataset, levels = c("Elevator", "Diamond", "Naval propulsion"))

# only choose MSE for the last 3 datasets
plot_combined_long2_mse <- plot_combined_long2_with_stability %>% filter(metric == "MSE")

# drop all splid_id if one of them has value NA
plot_combined_long2_mse <- plot_combined_long2_mse %>% group_by(dataset, split_id) %>% filter(!any(is.na(value))) %>% ungroup()

plot_combined_long2_mse <- plot_combined_long2_mse %>% group_by(dataset, split_id) %>% mutate(avg_mse_per_split = mean(value, na.rm = TRUE)) %>% ungroup() %>% group_by(dataset) %>% mutate(id_ordered = dense_rank(avg_mse_per_split)) %>% ungroup() %>% arrange(dataset, id_ordered)
View(plot_combined_long2_mse)


#colored version for the last 3 datasets 
mse_summary_table_simple2 <- plot_combined_long2_mse %>%
  group_by(dataset, method) %>%
  summarise(mean_mse = mean(value, na.rm = TRUE), .groups = "drop") %>%
  # Format the mean_mse but keep it as a separate column for HTML formatting
  mutate(
    formatted_mse = ifelse(mean_mse > 10000 | mean_mse < 0.1, 
                          formatC(mean_mse, format = "e", digits = 3), 
                          sprintf("%.3f", mean_mse)),
    method_chr = as.character(method),
    hex = unname(method_colors[method_chr])
  ) %>%
  group_by(dataset) %>%
  summarise(
    table_text_colored = paste(
      "<b>Mean MSE:</b>",
      paste0("<span style='color:", hex, "'>",
             method_chr, ": ", formatted_mse, "</span>",  # Use formatted_mse instead
             collapse = "<br>"),
      sep = "<br>"
    ),
    .groups = "drop"
  )


# Custom labeling function that uses scientific notation for very large/small numbers
scientific_if_needed <- function(x) {
  ifelse(abs(x) >= 10000 | (abs(x) < 0.01 & abs(x) > 0),
         formatC(x, format = "e", digits = 2),
         formatC(x, format = "f", digits = 3))
}


p_mse_ordered_with_avgMSE2 <- ggplot(plot_combined_long2_mse, aes(x = id_ordered, y = value, color = method)) +
  geom_point(alpha = 0.8, size = 4) +
  geom_line(alpha = 0.8, linewidth = 2) +
  # Add table as single text block with colored text
  geom_richtext(data = mse_summary_table_simple2,
                aes(x = Inf, y = Inf, label = table_text_colored),
                hjust = 1.05, vjust = 3.2,
                size = 17, family = "Times New Roman", fontface = "bold",
                fill = NA,          
                label.color = "gray30",   # Dark gray border
                label.padding = unit(0.35, "lines"),
                label.r = unit(0.2, "lines"),  # Rounded corners
                inherit.aes = FALSE) +
  facet_wrap(~ dataset, scales = "free_y") +
  # Force max value to appear on y-axis
  scale_y_continuous(
    breaks = function(x) {
      # Get pretty breaks
      pretty_breaks <- pretty(x, n = 5)
      # Always include the maximum value
      unique(c(pretty_breaks, max(x)))
    },
    labels = scientific_if_needed  # Custom conditional formatting
    )+
  labs(x = "Split index sorted by mean MSE across methods", y = "MSE", color = "Method") +
  scale_color_manual(values = method_colors) +
  guides(color = guide_legend(override.aes = list(size = 9))) +  # << enlarge color lines
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 40, hjust = 1, size = 50, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 50, family = "Times New Roman", face = "bold"),  
    axis.title = element_text(size = 80, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.box.margin = margin(t = 90, unit = "pt"),
    legend.text = element_text(size = 80, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 80, family = "Times New Roman", face = "bold"),
    legend.key.size = unit(8, "lines"),   # << increase dot/line box size
    legend.key.width = unit(8, "lines"),  # << make lines wider
    strip.text = element_text(size = 67, family = "Times New Roman", face = "bold"),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
ggsave("/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/p_mse_line_12data3.png", 
       plot =p_mse_ordered_with_avgMSE2,  width = 34, height = 30, dpi = 300)
print(p_mse_ordered_with_avgMSE2)



# Suppport metric for the last 3 datasets
plot_combined_long2_supp <- plot_combined_long2_with_stability %>%
  filter(metric == "Support", !is.na(value))


# Create bar plot 
p_support_bar3 <- ggplot(plot_combined_long2_supp, aes(y = as.factor(value), fill = method)) +
  geom_bar(
    orientation = "y",
    color = "gray",       # Border around bars
    linewidth = 0.3,
    alpha = 0.7
  ) +
  facet_grid2(dataset ~ method,
              scales = "free",
              independent = "x") +
  scale_y_discrete(
    labels = function(x) sprintf("%.0f", as.numeric(as.character(x))),  # Format support as integers
    breaks = function(x) x[seq(1, length(x), length.out = length(x))],
    expand = expansion(add = 1)  # Add slight space above and below
  ) +
  labs(x = "Count", y = "Support", fill = "Method") +
  scale_fill_manual(values = method_colors) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 8, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 8, family = "Times New Roman", face = "bold"),
    axis.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.text = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    strip.text = element_text(size = 10, family = "Times New Roman", face = "bold"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

# Display plot
print(p_support_bar3)

# Save output
ggsave(
  "/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/p_support_bar_12datalast3.png", 
  plot = p_support_bar3,
  width = 5,
  height = 5,
  dpi = 300
)


# Select only the number of violations metric for the last 3 datasets
plot_combined_long2_sign <- plot_combined_long2_with_stability %>%
  filter(metric == "Number of violations", !is.na(value))


# Bar plot
p_sign_bar3 <- ggplot(plot_combined_long2_sign, aes(y = as.factor(value), fill = method)) +
  geom_bar(
    orientation = "y",
    color = "gray",
    linewidth = 0.5,
    alpha = 0.7
  ) +
  facet_grid2(dataset ~ method,
              scales = "free",
              independent = "x") +
  # Format y labels and limit to ~6 ticks
  scale_y_discrete(
    labels = function(x) sprintf("%.0f", as.numeric(as.character(x))),
    breaks = function(x) x[seq(1, length(x), length.out = length(x))],
    expand = expansion(add = 1)  # Add slight space above and below
  ) +
  labs(x = "Count", y = "Number of violations", fill = "Method") +
  scale_fill_manual(values = method_colors) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 8, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 8, family = "Times New Roman", face = "bold"),
    axis.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.text = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    strip.text = element_text(size = 10, family = "Times New Roman", face = "bold"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

print(p_sign_bar3)

ggsave(
  "/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/p_sign_bar_12datalast3.png", 
  plot = p_sign_bar3,  
  width = 5, height = 5, dpi = 300
)



# Select only stability metric for the last 3 datasets
plot_combined_long2_stab <- plot_combined_long2_with_stability %>%
  filter(metric == "Stability", !is.na(value))

# Bar plot version
p_stab_bar3 <- ggplot(plot_combined_long2_stab, aes(y = as.factor(value), fill = method)) +
  geom_bar(
    orientation = "y",
    color = "gray",
    linewidth = 0.3,
    alpha = 0.7
  ) +
  facet_grid2(dataset ~ method,
              scales = "free",
              independent = "x") +
  scale_y_discrete(
    labels = function(x) sprintf("%.2f", as.numeric(as.character(x))),
    breaks = function(x) {
      # show roughly 6 evenly spaced labels
      x[seq(1, length(x), length.out = min(6, length(x)))]
    },
    expand = expansion(add = 1.5)  # Add slight space above and below
  ) +
  labs(x = "Count", y = "Random-split stability", fill = "Method") +
  scale_fill_manual(values = method_colors) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust=1, size = 8, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 8, family = "Times New Roman", face = "bold"),
    axis.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.text = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    strip.text = element_text(size = 8, family = "Times New Roman", face = "bold"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
print(p_stab_bar3)

ggsave(
  "/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/p_stab_bar_12datalast3.png", 
  plot = p_stab_bar3,  
  width = 5, height = 5, dpi = 300
)


```


# Graph for method with uniLasso-noSign: load the three datasets with uniLasso-noSign fit
```{r combine stability with mse, support, sign_diff}
### setup####

if (R.home() != "/scratch/users/aqwang/conda/envs/r_package/lib/R") {
  system("/scratch/users/aqwang/conda/envs/r_package/bin/Rscript -e 'rmarkdown::render(\"unilasso_12data_graph_final_v2.Rmd\")'")
  quit("no")
}

# check the R environment is r_package
R.home()

# set working directory
setwd("/accounts/grad/aqwang/unilasso/analysis/unilasso_12data_default_lambda")

# load packages 
library(uniLasso) # for unilasso 
library(glmnet) # for cv lasso 
library(dplyr)
library(tidyr)
library(ggplot2)

# Define all dataset names (remove "data_" prefix)
dataset_names <- c("diamond", "elevator", "naval_propulsion")

 

###################(1)load results for mse, support, sign_diff#################
# read csv file
results_all_splits <- read.csv("/accounts/grad/aqwang/unilasso/analysis/unilasso_12data_default_lambda/unilasso_12data_100splits_w_unilasso_nosign_train50percentresults.csv")


# using results_all_splits data frame to graph boxplot of MSE on the left and boxplot of support on the right for each dataset 


# Reshape data for plotting
plot_long <- results_all_splits %>%
  select(dataset, split_id, unilasso_loo_true_mse, unilasso_loo_true_nosign_mse, polish_unilasso_mse, lasso_cv_mse, unireg_mse, least_squares_mse,
         unilasso_loo_true_support, unilasso_loo_true_nosign_support, polish_unilasso_support, lasso_cv_support,unireg_support, least_squares_support,
         unilasso_loo_true_sign_diff, unilasso_loo_true_nosign_sign_diff, polish_unilasso_sign_diff,lasso_cv_sign_diff,unireg_sign_diff, least_squares_sign_diff) %>%
  pivot_longer(
    cols = c(unilasso_loo_true_mse, unilasso_loo_true_nosign_mse, polish_unilasso_mse, lasso_cv_mse, unireg_mse, least_squares_mse,
             unilasso_loo_true_support, unilasso_loo_true_nosign_support, polish_unilasso_support, lasso_cv_support, unireg_support, least_squares_support,
             unilasso_loo_true_sign_diff, unilasso_loo_true_nosign_sign_diff, polish_unilasso_sign_diff, lasso_cv_sign_diff, unireg_sign_diff, least_squares_sign_diff),
    names_to = c("method", ".value"),
    names_pattern = "(unilasso_loo_true|unilasso_loo_true_nosign|polish_unilasso|lasso_cv|unireg|least_squares)_(mse|support|sign_diff)"
  )

# Order datasets for consistent facetting
desired_order <- c( "elevator", "diamond", "naval_propulsion")
plot_long$dataset <- factor(plot_long$dataset, levels = desired_order)

# rename unilasso_loo_true to unilasso
plot_long$method <- recode(plot_long$method, unilasso_loo_true = "uniLasso", unilasso_loo_true_nosign = "uniLasso-noSign", polish_unilasso = "Polish", lasso_cv = "Lasso", unireg = "uniReg", least_squares = "LS")

# After creating plot_long and recoding the method names, add this line:
plot_long$method <- factor(plot_long$method, levels = c("LS", "Lasso", "uniReg", "uniLasso", "uniLasso-noSign", "Polish"))

#rename all datasets to have first letter capitalized and underscores replaced with spaces
plot_long$dataset <- recode(plot_long$dataset,
                            "elevator" = "Elevator",
                            "naval_propulsion" = "Naval propulsion",
                            "diamond" = "Diamond",
)

# Create combined long data with metric type including sign_diff
plot_combined_long <- plot_long %>%
  pivot_longer(
    cols = c(mse, support, sign_diff),
    names_to = "metric",
    values_to = "value"
  ) %>%
  mutate(
    metric = recode(metric, 
                   "mse" = "MSE", 
                   "support" = "Support",
                   "sign_diff" = "Number of violations"),
    metric = factor(metric, levels = c("MSE", "Support", "Number of violations")))

#########################################################


# Use similar colors for Polish, uniLasso, and uniReg
method_colors <- c(
  "uniLasso" = "#e41a1c",  # bright red
  "Polish"   = "#e75480",  # medium pink
  "uniReg"   = "#b03060",  # deep rose/magenta
  "uniLasso-noSign" = "#ff7f0e", # orange
  "Lasso"    = "#2a6eb1",  # balanced medium blue
  "LS"       = "#505050"   # darker gray
)



# choose two datasets: elevator, diamond
plot_combined_long <- plot_combined_long %>%
  filter(dataset %in% c("Elevator", "Diamond"))


# select only the MSE metric, delete all split_id if any value in that split is NA
plot_combined_long_mse <- plot_combined_long %>%
  filter(metric == "MSE") %>%
  group_by(dataset, split_id) %>%
  filter(!any(is.na(value))) %>%
  ungroup()


plot_combined_long_mse <- plot_combined_long_mse %>% group_by(dataset, split_id) %>% mutate(avg_mse_per_split = mean(value, na.rm = TRUE)) %>% ungroup() %>% group_by(dataset) %>% mutate(id_ordered = dense_rank(avg_mse_per_split)) %>% ungroup() %>% arrange(dataset, id_ordered)
View(plot_combined_long_mse)


#colored version for the last 2 datasets 
mse_summary_table_simple2 <- plot_combined_long_mse %>%
  group_by(dataset, method) %>%
  summarise(mean_mse = mean(value, na.rm = TRUE), .groups = "drop") %>%
  mutate(
    formatted_mse = ifelse(mean_mse > 10000 | mean_mse < 0.1, 
                          formatC(mean_mse, format = "e", digits = 3), 
                          sprintf("%.3f", mean_mse)),
    method_chr = trimws(as.character(method)),
    hex = unname(method_colors[method_chr])
  ) %>%
  group_by(dataset) %>%
  summarise(
    table_text_colored = paste(
      "<b>Mean MSE:</b>",
      paste0(
        "<span style='color:", hex, "'>", 
        method_chr, ": ", formatted_mse, 
        "</span>", 
        collapse = "<br>"
      ),
      sep = "<br>"
    ),
    .groups = "drop"
  )


# Custom labeling function that uses scientific notation for very large/small numbers
scientific_if_needed <- function(x) {
  ifelse(abs(x) >= 10000 | (abs(x) < 0.01 & abs(x) > 0),
         formatC(x, format = "e", digits = 2),
         formatC(x, format = "f", digits = 3))
}


p_mse_ordered_with_avgMSE2 <- ggplot(plot_combined_long_mse, aes(x = id_ordered, y = value, color = method)) +
  geom_point(alpha = 0.8, size = 4) +
  geom_line(alpha = 0.8, linewidth = 2) +
  # Add table as single text block with colored text
  geom_richtext(data = mse_summary_table_simple2,
                aes(x = -Inf, y = Inf, label = table_text_colored),
                hjust = -0.05, vjust = 4.3,
                size = 14, family = "Times New Roman", fontface = "bold",
                fill = NA,
                label.color = "gray30",   # Dark gray border
                label.padding = unit(0.35, "lines"),
                label.r = unit(0.2, "lines"),  # Rounded corners
                inherit.aes = FALSE) +
  facet_wrap(~ dataset, scales = "free_y") +
  # Force max value to appear on y-axis
  scale_y_continuous(
    breaks = function(x) {
      # Get pretty breaks
      pretty_breaks <- pretty(x, n = 5)
      # Always include the maximum value
      unique(c(pretty_breaks, max(x)))
    },
    labels = scientific_if_needed  # Custom conditional formatting
    )+
  labs(x = "Split index sorted by mean MSE across methods", y = "MSE", color = "Method") +
  scale_color_manual(values = method_colors) +
  guides(color = guide_legend(override.aes = list(size = 9))) +  # << enlarge color lines
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 40, hjust = 1, size = 50, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 50, family = "Times New Roman", face = "bold"),  
    axis.title = element_text(size = 80, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.box.margin = margin(t = 70, unit = "pt"),
    legend.text = element_text(size = 65, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 65, family = "Times New Roman", face = "bold"),
    legend.key.size = unit(8, "lines"),   # << increase dot/line box size
    legend.key.width = unit(8, "lines"),  # << make lines wider
    strip.text = element_text(size = 60, family = "Times New Roman", face = "bold"),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
ggsave("/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/p_mse_line_12data2_nosign.png", 
       plot =p_mse_ordered_with_avgMSE2,  width = 40, height = 40, dpi = 300)
print(p_mse_ordered_with_avgMSE2)


# Support metric for the last 2 datasets
plot_combined_long_supp <- plot_combined_long %>%
  filter(metric == "Support", !is.na(value))

# Create bar plot
p_support_bar2 <- ggplot(plot_combined_long_supp, aes(y = as.factor(value), fill = method)) +
  geom_bar(
    orientation = "y",
    color = "gray",       # Border around bars
    linewidth = 0.3,
    alpha = 0.7
  ) +
  facet_grid2(dataset ~ method,
              scales = "free",
              independent = "x") +
  scale_y_discrete(
    labels = function(x) sprintf("%.0f", as.numeric(as.character(x))),  # Format support as integers
    breaks = function(x) x[seq(1, length(x), length.out = length(x))],
    expand = expansion(add = 1)  # Add slight space above and below
  ) +
  labs(x = "Count", y = "Support", fill = "Method") +
  scale_fill_manual(values = method_colors) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 8, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 8, family = "Times New Roman", face = "bold"),
    axis.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.text = element_text(size = 12, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 12, family = "Times New Roman", face = "bold"),
    strip.text = element_text(size = 10, family = "Times New Roman", face = "bold"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

# Display plot
print(p_support_bar2)

# Save output
ggsave(
  "/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/p_support_bar_12datalast2_nosign.png", 
  plot = p_support_bar2,
  width = 10,
  height = 8,
  dpi = 300
)

```


# Final version Part 2: updated bootstrap results for all 12 datasets
```{r load updated bootstrap results and make some plots}
boot_results <- read.csv("/accounts/grad/aqwang/unilasso/analysis/unilasso_12data_default_lambda/unilasso_12data_100bootstrap.csv")


# Reshape data for plotting
plot_long <- boot_results %>%
  select(dataset, bootstrap_id, unilasso_loo_true_mse, polish_unilasso_mse, lasso_cv_mse, unireg_mse, least_squares_mse,
         unilasso_loo_true_support, polish_unilasso_support, lasso_cv_support,unireg_support, least_squares_support) %>%
  pivot_longer(
    cols = c(unilasso_loo_true_mse, polish_unilasso_mse, lasso_cv_mse, unireg_mse, least_squares_mse,
             unilasso_loo_true_support, polish_unilasso_support, lasso_cv_support, unireg_support, least_squares_support),
    names_to = c("method", ".value"),
    names_pattern = "(unilasso_loo_true|polish_unilasso|lasso_cv|unireg|least_squares)_(mse|support)"
  )

# Order datasets for consistent facetting
desired_order <- c(
  "ca_housing", "debutanizer", "insurance", "kin8nm", 
  "computer", "elevator", "energy_efficiency", "miami_housing", "naval_propulsion",
  "diamond", "protein_structure", "qsar"
)


plot_long$dataset <- factor(plot_long$dataset, levels = desired_order)

# rename unilasso_loo_true to unilasso
plot_long$method <- recode(plot_long$method, unilasso_loo_true = "uniLasso", polish_unilasso = "Polish", lasso_cv = "Lasso", unireg = "uniReg", least_squares = "LS")

# After creating plot_long and recoding the method names, add this line:
plot_long$method <- factor(plot_long$method, levels = c("LS", "Lasso", "uniReg", "uniLasso", "Polish"))

#rename all datasets to have first letter capitalized and underscores replaced with spaces
plot_long$dataset <- recode(plot_long$dataset,
                            "ca_housing" = "CA housing",
                            "debutanizer" = "Debutanizer",
                            "insurance" = "Insurance",
                            "kin8nm" = "Kin8nm",
                            "computer" = "Computer",
                            "elevator" = "Elevator",
                            "energy_efficiency" = "Energy efficiency",
                            "miami_housing" = "Miami housing",
                            "naval_propulsion" = "Naval propulsion",
                            "diamond" = "Diamond",
                            "protein_structure" = "Protein structure",
                            "qsar" = "QSAR"
)

# Create combined long data with metric type including sign_diff
plot_combined_long <- plot_long %>%
  pivot_longer(
    cols = c(mse, support),
    names_to = "metric",
    values_to = "value"
  ) %>%
  mutate(
    metric = recode(metric, 
                   "mse" = "MSE", 
                   "support" = "Support"),
    metric = factor(metric, levels = c("MSE", "Support"))
  )


method_colors <- c(
  "uniLasso" = "#e41a1c",  # bright red
  "Polish"   = "#e75480",  # medium pink
  "uniReg"   = "#b03060",  # deep rose/magenta
  "Lasso"    = "#2a6eb1",  # balanced medium blue
  "LS"       = "#505050"   # darker gray
)

#reorder datasets
plot_combined_long$dataset <- factor(plot_combined_long$dataset, levels = c("CA housing", "Debutanizer", "Insurance", "Kin8nm", "Computer", "Energy efficiency","Miami housing", "Protein structure", "QSAR", "Elevator", "Diamond", "Naval propulsion"))


###############################data wrangling DONE#####################################


################### Choose the last three datasets for the main text###########################
plot_combined_long3 <- plot_combined_long %>% filter(dataset %in% c("Elevator", "Diamond", "Naval propulsion")) 



library(dplyr)
library(ggrepel)


# Compute mean and 1 SD for each dataset  metric  method
plot_bootstrap_summary <- plot_combined_long3 %>%
  group_by(dataset, metric, method) %>%
  summarise(
    mean_value = mean(value, na.rm = TRUE),
    sd_value   = sd(value, na.rm = TRUE),
    lower = mean_value - sd_value,
    upper = mean_value + sd_value,
    .groups = "drop"
  ) %>%
  mutate(
    # Format values for labels only (keep as separate columns)
    mean_formatted = ifelse(abs(mean_value) >= 10000 | abs(mean_value) < 0.09,
                           formatC(mean_value, format = "e", digits = 3),
                           formatC(mean_value, format = "f", digits = 2)),
    
    sd_formatted = ifelse(abs(sd_value) >= 10000 | abs(sd_value) < 0.09,
                         formatC(sd_value, format = "e", digits = 3),
                         formatC(sd_value, format = "f", digits = 2))
  ) 


# 3. Plot with dynamic repel - labels to the left of error bar centers
plot_bootstrap_points_sd <- ggplot(plot_combined_long3, aes(x = method, y = value, color = method)) +
  geom_jitter(width = 0.15, alpha = 0.4, size = 0.8) +
  geom_errorbar(
    data = plot_bootstrap_summary,
    aes(x = method, ymin = lower, ymax = upper),
    width = 0.25,
    linewidth = 0.8,
    color = "black",
    inherit.aes = FALSE
  ) +
  geom_point(
    data = plot_bootstrap_summary,
    aes(x = method, y = mean_value),
    shape = 23, size = 3.5, fill = "black", color = "black",
    inherit.aes = FALSE
  ) +
  geom_text_repel(
    data = plot_bootstrap_summary,
    aes(
      x = as.numeric(method) - 0.3,  # Position to the left of each method
      y = mean_value,                # Position at the mean (center of error bar)
      label = paste0(mean_formatted, "  ", sd_formatted)
    ),
    angle = 90,              # Vertical text (90 degrees)
    size = 4,
    family = "Times New Roman",
    fontface = "bold",
    color = "black",
    direction = "y",         # Allow vertical movement only
    force = 0,
    max.overlaps = 100,
    box.padding = 0.1,
    point.padding = 0.1,
    min.segment.length = 0,
    segment.color = "gray60",
    segment.size = 0.25,
    hjust = 0.5,            # Center the text on the anchor point
    vjust = 0.5,            # Center the text vertically
    inherit.aes = FALSE
  ) +
  facet_grid2(
    dataset ~ metric,
    switch = "y",
    scales = "free_y",
    independent = "y"
  ) +
  coord_cartesian(clip = "off") +
  labs(x = "Method", y = NULL, color = "Method") +
  scale_color_manual(values = method_colors) +
  scale_y_continuous(expand = expansion(mult = c(0.2, 0.2))) +  # Add extra space above for labels
  guides(color = guide_legend(override.aes = list(size = 4))) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 1, size = 18, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 16, family = "Times New Roman", face = "bold"),
    axis.title = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.text = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.key.width = unit(5, "lines"),  # << make lines wider
    strip.text = element_text(size = 20, family = "Times New Roman", face = "bold"),
    strip.placement = "outside",
    panel.spacing.y = unit(0.7, "cm"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

print(plot_bootstrap_points_sd)

ggsave("/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/p_mse_supp_bootstrap_3data.png", plot = plot_bootstrap_points_sd, width = 12, height = 18, dpi = 300)






################### Choose the 9 datasets for the appendix ###########################
plot_combined_long9 <- plot_combined_long %>% filter(dataset %in% c("CA housing", "Debutanizer", "Insurance", "Kin8nm", "Computer", "Energy efficiency", "Miami housing", "Protein structure", "QSAR")) 



library(dplyr)
library(ggrepel)


# Compute mean and 1 SD for each dataset  metric  method
plot_bootstrap_summary <- plot_combined_long9 %>%
  group_by(dataset, metric, method) %>%
  summarise(
    mean_value = mean(value, na.rm = TRUE),
    sd_value   = sd(value, na.rm = TRUE),
    lower = mean_value - sd_value,
    upper = mean_value + sd_value,
    .groups = "drop"
  ) %>%
  mutate(
    # Format values for labels only (keep as separate columns)
    mean_formatted = ifelse(abs(mean_value) >= 10000| abs(mean_value) < 0.09 & abs(mean_value) > 0,
                           formatC(mean_value, format = "e", digits = 3),
                           formatC(mean_value, format = "f", digits = 2)),
    
    sd_formatted = ifelse(abs(sd_value) >= 10000 | abs(sd_value) < 0.09 & abs(sd_value) > 0,
                         formatC(sd_value, format = "e", digits = 3),
                         formatC(sd_value, format = "f", digits = 2))
  ) 


# 3. Plot with dynamic repel - labels to the left of error bar centers. only for the 5 datasets: CA housing, Debutanizer, Insurance, Kin8nm, Computer
# Only plot for the 5 datasets: CA housing, Debutanizer, Insurance, Kin8nm, Computer
plot_combined_long5 <- plot_combined_long9 %>%
  filter(dataset %in% c("CA housing", "Debutanizer", "Insurance", "Kin8nm", "Computer"))

plot_bootstrap_summary5 <- plot_bootstrap_summary %>%
  filter(dataset %in% c("CA housing", "Debutanizer", "Insurance", "Kin8nm", "Computer"))

plot_bootstrap_points_sd5 <- ggplot(plot_combined_long5, aes(x = method, y = value, color = method)) +
  geom_jitter(width = 0.15, alpha = 0.4, size = 0.8) +
  geom_errorbar(
    data = plot_bootstrap_summary5,
    aes(x = method, ymin = lower, ymax = upper),
    width = 0.25,
    linewidth = 0.8,
    color = "black",
    inherit.aes = FALSE
  ) +
  geom_point(
    data = plot_bootstrap_summary5,
    aes(x = method, y = mean_value),
    shape = 23, size = 3.5, fill = "black", color = "black",
    inherit.aes = FALSE
  ) +
  geom_text_repel(
    data = plot_bootstrap_summary5,
    aes(
      x = as.numeric(method) - 0.3,
      y = mean_value,
      label = paste0(mean_formatted, "  ", sd_formatted)
    ),
    angle = 90,
    size = 4,
    family = "Times New Roman",
    fontface = "bold",
    color = "black",
    direction = "y",
    force = 0,
    max.overlaps = 100,
    box.padding = 0.1,
    point.padding = 0.1,
    min.segment.length = 0,
    segment.color = "gray60",
    segment.size = 0.25,
    hjust = 0.5,
    vjust = 0.5,
    inherit.aes = FALSE
  ) +
  facet_grid2(
    dataset ~ metric,
    switch = "y",
    scales = "free_y",
    independent = "y"
  ) +
  coord_cartesian(clip = "off") +
  labs(x = "Method", y = NULL, color = "Method") +
  scale_color_manual(values = method_colors) +
  # Add 30% extra space at bottom and top
  scale_y_continuous(expand = expansion(mult = c(0.3, 0.3)))+
      # ADD THIS LINE to make legend dots larger
  guides(color = guide_legend(override.aes = list(size = 4))) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 1, size = 18, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 16, family = "Times New Roman", face = "bold"),
    axis.title = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.text = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.key.width = unit(5, "lines"),  # << make lines wider
    strip.text = element_text(size = 20, family = "Times New Roman", face = "bold"),
    strip.placement = "outside",
    panel.spacing.y = unit(0.7, "cm"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

print(plot_bootstrap_points_sd5)

ggsave("/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/app_mse_supp_bootstrap_5data.png", plot = plot_bootstrap_points_sd5, width = 12, height = 18, dpi = 300)


# Now plot for the remaining 4 datasets: Energy efficiency, Miami housing, Protein structure, QSAR
plot_combined_long4 <- plot_combined_long9 %>%
  filter(dataset %in% c("Energy efficiency", "Miami housing", "Protein structure", "QSAR"))

plot_bootstrap_summary4 <- plot_bootstrap_summary %>%
  filter(dataset %in% c("Energy efficiency", "Miami housing", "Protein structure", "QSAR"))


plot_bootstrap_points_sd4 <- ggplot(plot_combined_long4, aes(x = method, y = value, color = method)) +
  geom_jitter(width = 0.15, alpha = 0.4, size = 0.8) +
  geom_errorbar(
    data = plot_bootstrap_summary4,
    aes(x = method, ymin = lower, ymax = upper),
    width = 0.25,
    linewidth = 0.8,
    color = "black",
    inherit.aes = FALSE
  ) +
  geom_point(
    data = plot_bootstrap_summary4,
    aes(x = method, y = mean_value),
    shape = 23, size = 3.5, fill = "black", color = "black",
    inherit.aes = FALSE
  ) +
  geom_text_repel(
    data = plot_bootstrap_summary4,
    aes(
      x = as.numeric(method) - 0.3,
      y = mean_value,
      label = paste0(mean_formatted, "  ", sd_formatted)
    ),
    angle = 90,
    size = 4,
    family = "Times New Roman",
    fontface = "bold",
    color = "black",
    direction = "y",
    force = 0,
    max.overlaps = 100,
    box.padding = 0.1,
    point.padding = 0.1,
    min.segment.length = 0,
    segment.color = "gray60",
    segment.size = 0.25,
    hjust = 0.5,
    vjust = 0.5,
    inherit.aes = FALSE
  ) +
  facet_grid2(
    dataset ~ metric,
    switch = "y",
    scales = "free_y",
    independent = "y"
  ) +
  coord_cartesian(clip = "off") +
  labs(x = "Method", y = NULL, color = "Method") +
  scale_color_manual(values = method_colors) +
  scale_y_continuous(expand = expansion(mult = c(0.3, 0.3))) +
    # ADD THIS LINE to make legend dots larger
  guides(color = guide_legend(override.aes = list(size = 4))) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 1, size = 18, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 16, family = "Times New Roman", face = "bold"),
    axis.title = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.text = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.key.width = unit(5, "lines"),  # << make lines wider
    strip.text = element_text(size = 20, family = "Times New Roman", face = "bold"),
    strip.placement = "outside",
    panel.spacing.y = unit(0.7, "cm"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

print(plot_bootstrap_points_sd4)

ggsave("/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/app_mse_supp_bootstrap_4data.png", plot = plot_bootstrap_points_sd4, width = 12, height = 17, dpi = 300)
###########################bootstrap DONE#####################################



########################### for prediction interval, make a plot of average width of prediction interval for each dataset with standard error bar
pred_int <- read.csv("/accounts/grad/aqwang/unilasso/analysis/unilasso_12data_default_lambda/unilasso_12data_100bootstrap_pred_int.csv")


###############prediction interval coverage#############################
pred_int_coverage <- pred_int %>%
  select(dataset, method, coverage) %>%
  pivot_wider(names_from = method, values_from = coverage) %>%
  rename(LS = least_squares,
        Lasso = lasso_cv,
        uniReg = uniReg,
        uniLasso = uniLasso_loo_true,
        Polish = polish_uniLasso) %>%
  select(dataset, LS, Lasso, uniReg, uniLasso, Polish) %>%
  mutate(across(-dataset, ~ round(., 3)))

pred_int_coverage$dataset <- recode(pred_int_coverage$dataset,
                            "ca_housing" = "CA housing",
                            "debutanizer" = "Debutanizer",
                            "insurance" = "Insurance",
                            "kin8nm" = "Kin8nm",
                            "computer" = "Computer",
                            "elevator" = "Elevator",
                            "energy_efficiency" = "Energy efficiency",
                            "miami_housing" = "Miami housing",
                            "naval_propulsion" = "Naval propulsion",
                            "diamond" = "Diamond",
                            "protein_structure" = "Protein structure",
                            "qsar" = "QSAR"
)


# reorder the row of pred_int_coverage to match the desired order
pred_int_coverage$dataset <- factor(pred_int_coverage$dataset, levels = c("CA housing", "Debutanizer", "Insurance", "Kin8nm", "Computer", "Energy efficiency","Miami housing", "Protein structure", "QSAR", "Elevator", "Diamond", "Naval propulsion"))
pred_int_coverage <- pred_int_coverage %>%
  arrange(dataset)


# Calculate row averages (across methods for each dataset), rounded to 3 decimal places
pred_int_coverage$row_avg <- round(rowMeans(pred_int_coverage[, c("LS", "Lasso", "uniReg", "uniLasso", "Polish")], na.rm = TRUE), 3)

# Calculate column averages (across datasets for each method)
col_avgs <- colMeans(pred_int_coverage[, c("LS", "Lasso", "uniReg", "uniLasso", "Polish", "row_avg")], na.rm = TRUE)

# Optionally, print column averages
print(col_avgs)

pred_int_coverage$dataset <- as.character(pred_int_coverage$dataset)

# add col avg to the bottom of pred_int_coverage
pred_int_coverage <- rbind(pred_int_coverage, c("Column Average", round(col_avgs, 3)))

# save as csv
write.csv(pred_int_coverage, "/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/pred_int_coverage_12datasets.csv", row.names = FALSE)





###############prediction interval width#############################
load("/accounts/grad/aqwang/unilasso/analysis/unilasso_12data_default_lambda/unilasso_12data_100bootstrap_interval_widths.RData") #named all_interval_widths

# Convert the first one in the list to dataframe
pred_int_width <- do.call(rbind, lapply(names(all_interval_widths), function(dataset_name) {
  df <- as.data.frame(all_interval_widths[[dataset_name]])
  df$dataset <- dataset_name
  return(df)
}))

# make long format
pred_int_width <- pred_int_width %>%
  select(dataset, uniLasso_loo_true, polish_uniLasso, lasso_cv, uniReg, least_squares) %>%
  pivot_longer(
    cols = -dataset,
    names_to = "method",
    values_to = "width"
  ) %>% # recode method names
  mutate(
    method = recode(method, uniLasso_loo_true = "uniLasso", polish_uniLasso = "Polish", lasso_cv = "Lasso", uniReg = "uniReg", least_squares = "LS"),
    method = factor(method, levels = c("LS", "Lasso", "uniReg", "uniLasso", "Polish"))
  )

# rename all datasets to have first letter capitalized and underscores replaced with spaces
pred_int_width$dataset <- recode(pred_int_width$dataset ,
                            "ca_housing" = "CA housing",
                            "debutanizer" = "Debutanizer",
                            "insurance" = "Insurance",
                            "kin8nm" = "Kin8nm",
                            "computer" = "Computer",
                            "elevator" = "Elevator",
                            "energy_efficiency" = "Energy efficiency",
                            "miami_housing" = "Miami housing",
                            "naval_propulsion" = "Naval propulsion",
                            "diamond" = "Diamond",
                            "protein_structure" = "Protein structure",
                            "qsar" = "QSAR"
)

# Use similar colors for Polish, uniLasso, and uniReg
method_colors <- c(
  "uniLasso" = "#e41a1c",  # bright red
  "Polish"   = "#e75480",  # medium pink
  "uniReg"   = "#b03060",  # deep rose/magenta
  "Lasso"    = "#2a6eb1",  # balanced medium blue
  "LS"       = "#505050"   # darker gray
)

#reorder datasets
pred_int_width$dataset  <- factor(pred_int_width$dataset, levels = c("CA housing", "Debutanizer", "Insurance", "Kin8nm", "Computer", "Energy efficiency","Miami housing", "Protein structure", "QSAR", "Elevator", "Diamond", "Naval propulsion"))



################### Choose the last three datasets for prediction interval width ###########################
pred_int_width3 <- pred_int_width %>% filter(dataset %in% c("Elevator", "Diamond", "Naval propulsion")) 

# order the dataset factor levels
pred_int_width3$dataset <- factor(pred_int_width3$dataset, levels = c("Elevator", "Diamond", "Naval propulsion"))

library(dplyr)
library(ggrepel)

# Compute mean and 1 SD for each dataset  method for prediction interval width
pred_int_width_summary <- pred_int_width3 %>%
  group_by(dataset, method) %>%
  summarise(
    mean_value = mean(width, na.rm = TRUE),
    sd_value   = sd(width, na.rm = TRUE),
    lower = mean_value - sd_value,
    upper = mean_value + sd_value,
    .groups = "drop"
  ) %>%
  mutate(
    # Format values for labels only (keep as separate columns)
    mean_formatted = ifelse(abs(mean_value) >= 10000 | abs(mean_value) < 0.09,
                           formatC(mean_value, format = "e", digits = 3),
                           formatC(mean_value, format = "f", digits = 2)),
    
    sd_formatted = ifelse(abs(sd_value) >= 10000 | abs(sd_value) < 0.09,
                         formatC(sd_value, format = "e", digits = 3),
                         formatC(sd_value, format = "f", digits = 2))
  ) 

# Plot prediction interval widths with error bars and labels
plot_pred_int_width_sd <- ggplot(pred_int_width3, aes(x = method, y = width, color = method)) +
  geom_jitter(width = 0.15, alpha = 0.4, size = 0.8) +
  geom_errorbar(
    data = pred_int_width_summary,
    aes(x = method, ymin = lower, ymax = upper),
    width = 0.25,
    linewidth = 0.8,
    color = "black",
    inherit.aes = FALSE
  ) +
  geom_point(
    data = pred_int_width_summary,
    aes(x = method, y = mean_value),
    shape = 23, size = 3.5, fill = "black", color = "black",
    inherit.aes = FALSE
  ) +
  geom_text_repel(
    data = pred_int_width_summary,
    aes(
      x = as.numeric(method) - 0.3,  # Position to the left of each method
      y = mean_value,                # Position at the mean (center of error bar)
      label = paste0(mean_formatted, "  ", sd_formatted)
    ),
    angle = 90,              # Vertical text (90 degrees)
    size = 4,
    family = "Times New Roman",
    fontface = "bold",
    color = "black",
    direction = "y",         # Allow vertical movement only
    force = 0,
    max.overlaps = 100,
    box.padding = 0.1,
    point.padding = 0.1,
    min.segment.length = 0,
    segment.color = "gray60",
    segment.size = 0.25,
    hjust = 0.5,            # Center the text on the anchor point
    vjust = 0.5,            # Center the text vertically
    inherit.aes = FALSE
  ) +
  facet_wrap(~ dataset, scales = "free_y") +
  coord_cartesian(clip = "off") +
  labs(x = "Method", y = "Prediction interval width (nominal 95%)", color = "Method") +
  scale_color_manual(values = method_colors) +
  scale_y_continuous(expand = expansion(mult = c(0.2, 0.2))) +  # Add extra space above for labels
  guides(color = guide_legend(override.aes = list(size = 6))) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 1, size = 18, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 16, family = "Times New Roman", face = "bold"),
    axis.title = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.text = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.key.width = unit(5, "lines"),  # make lines wider
    strip.text = element_text(size = 20, family = "Times New Roman", face = "bold"),
    strip.placement = "outside",
    panel.spacing.y = unit(0.7, "cm"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

print(plot_pred_int_width_sd)

ggsave("/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/pred_int_width_bootstrap_3data.png", 
       plot = plot_pred_int_width_sd, width = 12, height = 8, dpi = 300)






################### Appendix: Choose first 9 datasets for prediction interval width ###########################
pred_int_width9 <- pred_int_width %>% filter(dataset %in% c("CA housing", "Debutanizer", "Insurance", "Kin8nm", "Computer", "Energy efficiency","Miami housing", "Protein structure", "QSAR")) 

# order the dataset factor levels
pred_int_width9$dataset <- factor(pred_int_width9$dataset, levels = c("CA housing", "Debutanizer", "Insurance", "Kin8nm", "Computer", "Energy efficiency","Miami housing", "Protein structure", "QSAR"))

library(dplyr)
library(ggrepel)

# Compute mean and 1 SD for each dataset  method for prediction interval width
pred_int_width_summary <- pred_int_width9 %>%
  group_by(dataset, method) %>%
  summarise(
    mean_value = mean(width, na.rm = TRUE),
    sd_value   = sd(width, na.rm = TRUE),
    lower = mean_value - sd_value,
    upper = mean_value + sd_value,
    .groups = "drop"
  ) %>%
  mutate(
    # Format values for labels only (keep as separate columns)
    mean_formatted = ifelse(abs(mean_value) >= 10000 | abs(mean_value) < 0.09,
                           formatC(mean_value, format = "e", digits = 3),
                           formatC(mean_value, format = "f", digits = 2)),
    
    sd_formatted = ifelse(abs(sd_value) >= 10000 | abs(sd_value) < 0.09,
                         formatC(sd_value, format = "e", digits = 3),
                         formatC(sd_value, format = "f", digits = 2))
  ) 

# Plot prediction interval widths with error bars and labels
plot_pred_int_width_sd9 <- ggplot(pred_int_width9, aes(x = method, y = width, color = method)) +
  geom_jitter(width = 0.15, alpha = 0.4, size = 0.8) +
  geom_errorbar(
    data = pred_int_width_summary,
    aes(x = method, ymin = lower, ymax = upper),
    width = 0.25,
    linewidth = 0.8,
    color = "black",
    inherit.aes = FALSE
  ) +
  geom_point(
    data = pred_int_width_summary,
    aes(x = method, y = mean_value),
    shape = 23, size = 3.5, fill = "black", color = "black",
    inherit.aes = FALSE
  ) +
  geom_text_repel(
    data = pred_int_width_summary,
    aes(
      x = as.numeric(method) - 0.3,  # Position to the left of each method
      y = mean_value,                # Position at the mean (center of error bar)
      label = paste0(mean_formatted, "  ", sd_formatted)
    ),
    angle = 90,              # Vertical text (90 degrees)
    size = 4,
    family = "Times New Roman",
    fontface = "bold",
    color = "black",
    direction = "y",         # Allow vertical movement only
    force = 0,
    max.overlaps = 100,
    box.padding = 0.1,
    point.padding = 0.1,
    min.segment.length = 0,
    segment.color = "gray60",
    segment.size = 0.25,
    hjust = 0.5,            # Center the text on the anchor point
    vjust = 0.5,            # Center the text vertically
    inherit.aes = FALSE
  ) +
  facet_wrap(~ dataset, scales = "free_y") +
  coord_cartesian(clip = "off") +
  labs(x = "Method", y = "Prediction interval width (nominal 95%)", color = "Method") +
  scale_color_manual(values = method_colors) +
  scale_y_continuous(expand = expansion(mult = c(0.2, 0.2))) +  # Add extra space above for labels
  guides(color = guide_legend(override.aes = list(size = 6))) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 1, size = 18, family = "Times New Roman", face = "bold"),
    axis.text.y = element_text(size = 16, family = "Times New Roman", face = "bold"),
    axis.title = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.position = "bottom",
    legend.text = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.title = element_text(size = 20, family = "Times New Roman", face = "bold"),
    legend.key.width = unit(5, "lines"),  # make lines wider
    strip.text = element_text(size = 20, family = "Times New Roman", face = "bold"),
    strip.placement = "outside",
    panel.spacing.y = unit(0.7, "cm"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

print(plot_pred_int_width_sd9)

ggsave("/accounts/grad/aqwang/unilasso/figures_12data/figure_default_lambda/pred_int_width_bootstrap_9data.png", 
       plot = plot_pred_int_width_sd9, width = 15, height = 24, dpi = 300)
```